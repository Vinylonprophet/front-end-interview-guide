# JavaScript面试题

## 类型

### 1. 基本类型有哪些？

1. **数字（Number）**：表示整数和浮点数，如1, 3.14等。
2. **字符串（String）**：表示文本数据，如"Hello, World!"等。
3. **布尔值（Boolean）**：表示逻辑值，true或false。
4. **空值（Null）**：表示一个空值或者“无”。
5. **未定义（Undefined）**：表示一个未定义的值。
6. **符号（Symbol）**（ES6新增）：表示唯一的标识符。
7. **BigInt**（ES11新增）：表示任意精度的整数。

这些基本类型是 JavaScript 中最基本的数据类型，它们不是对象，不具有方法。

在内存中占据固定大小，保存在栈内存中。



### 2. 栈内存和堆内存的区别是什么？

在计算机内存管理中，栈内存（Stack）和堆内存（Heap）是两种不同的内存分配方式，它们有以下区别：

1. **分配方式**：
   - **栈内存**：栈内存是一种**连续的内存空间**，数据在栈上的分配和释放是由系统自动管理的，采用**先进先出**的方式分配内存。当一个函数被调用时，函数的局部变量和参数等数据会被分配到栈上，函数执行完毕后，这些数据会被自动释放。
   - **堆内存**：堆内存是一种**离散的内存空间**，数据在堆上的分配和释放需要手动管理。在堆上分配的数据的生命周期由程序员控制，需要手动释放内存，否则可能导致内存泄漏。

2. **速度**：
   - **栈内存**：栈内存的分配和释放是由系统自动管理的，分配和释放的速度较**快**。
   - **堆内存**：堆内存的分配和释放需要手动管理，因此速度较慢。

3. **存储方式**：
   - **栈内存**：栈内存通常用于存储函数调用时的局部变量、函数参数等数据，数据的大小是固定的，存储的是**基本类型数据**。
   - **堆内存**：堆内存用于存储动态分配的数据，如对象、数组等，数据的大小和结构可以动态改变，存储的是**引用类型数据**。

4. **作用域**：
   - **栈内存**：栈内存中的数据的作用域仅限于所属的函数，函数执行完毕后，数据**会被自动释放**。
   - **堆内存**：堆内存中的数据的作用域可以跨越函数和代码块，由程序员**手动管理内存的释放**。

总的来说，栈内存适合存储函数调用时的局部变量和参数等数据，而堆内存适合存储动态分配的数据，如对象、数组等。



### 3. 引用类型有哪些？

1. **对象（Object）**：对象是JavaScript中最基本的引用类型，用于存储多个键值对。对象可以通过字面量、构造函数或对象字面量的方式创建。

2. **数组（Array）**：数组是一种特殊的对象，用于存储有序的数据集合。数组的元素可以是任意数据类型，包括基本类型和其他引用类型。

3. **函数（Function）**：函数也是一种对象，用于封装可执行的代码块。函数可以被调用执行，并且可以接收参数和返回值。

4. **日期（Date）**：日期对象用于处理日期和时间，包括日期的获取、设置和计算等操作。

5. **正则表达式（RegExp）**：正则表达式对象用于进行字符串的模式匹配和替换操作。

6. **Map**：Map是ES6新增的引用类型，它是一种键值对的集合，其中键可以是任意数据类型。

7. **Set**：Set是ES6新增的引用类型，它是一种值的集合，其中每个值都是唯一的。

8. **Symbol**：Symbol是ES6新增的基本类型，但它也可以作为引用类型使用，用于创建唯一的标识符。

这些引用类型都具有自己的特性和方法，用于处理不同类型的数据和实现不同的功能。



### 4. null和undefined之间的区别是什么？

- null用于显式地表示一个变量没有值。
- undefined用于表示变量未赋值或访问不存在的属性时的返回值。
- 在实际编程中，null通常用于初始化一个变量为“无值”，而undefined通常用于表示变量未初始化或某些操作的结果。



### 5. 类型强制转换是什么？

- 在显式转换中，我们使用内置函数或操作符，如`Number()`和`String()`，来将值转换为特定类型。
- 隐式转换中，JavaScript根据运算、比较或其他操作的需要，自动进行类型转换。
- 通常会优先考虑字符串类型。



### 6. 如何检查 JavaScript 中变量的类型？

`typeof`运算符可以用于检查任何类型的变量，包括基本类型和引用类型。

`typeof null`返回 "object"，因为进制前几位和object一样。所以可以用 `=== null`来判断。

可以使用 `instanceof` 运算符来检查一个对象是否是特定类型的实例。

可以使用`Object.prototype.toString.call()`方法来获取其内部属性 `[[Class]]` 的值，然后根据该值返回一个表示变量类型的字符串。



### 7. `==` 和 `===` 有什么区别？

`==` 是相等运算符，如果比较的变量类型不同，会进行类型强制转换。`===` 是严格相等运算符，不进行类型转换，只有值和类型完全相同才返回 true。



### 8.`instanceof` 运算符是什么？它是如何工作的？

`instanceof` 运算符用于检查一个对象是否是某个构造函数的实例。



### 9. let、const 和 var 有什么区别？

`var` 是函数作用域，而 `let` 和 `const` 是块作用域。`const` 用于声明不能重新赋值的变量，而 `let` 和 `var` 可以重新赋值。



### 10. 暂时性死区是什么？

也就是let和const不能变量提升。



### 11. [] == ![]` 的结果是什么？

这个表达式的结果是 `true`，因为 `![]` 被强制转换为 `false`，而 `[]` 在比较之前被强制转换为空字符串 `""`，而空字符串接着被强制转换为 `0`。因此，`0 == false` 被评估为 `true`。



### 12. 对象的key可以是数字吗？

可以。



### 13. 浅拷贝/深度拷贝的区别？

**浅拷贝（Shallow Copy）：**

浅拷贝是指创建一个新对象或数组，将原始对象或数组的属性或元素复制到新对象或数组中。但是，如果原始对象或数组的属性或元素是引用类型（如对象、数组等），则浅拷贝只会复制它们的引用，而不会复制它们的值。因此，如果修改新对象或数组中的属性或元素，原始对象或数组中对应的属性或元素也会受到影响。

`Object.assign({}, obj);`

**深拷贝（Deep Copy）：**

深拷贝是指创建一个新对象或数组，并递归地将原始对象或数组的所有属性或元素以及它们的值复制到新对象或数组中。深拷贝会完全复制原始对象或数组的结构和值，因此修改新对象或数组不会影响到原始对象或数组。

```javascript
function deepCopy(obj) {
  // 检查是否为对象或数组，如果不是则直接返回
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }
  
  // 创建一个新的对象或数组，根据原始对象或数组的类型来决定
  let copy = Array.isArray(obj) ? [] : {};
  
  // 遍历原始对象或数组的属性或元素，并递归地复制到新对象或数组中
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      copy[key] = deepCopy(obj[key]);
    }
  }
  
  return copy;
}

// 测试深拷贝函数
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = deepCopy(obj1);

obj2.a = 3;
obj2.b.c = 4;

console.log(obj1); // 输出: { a: 1, b: { c: 2 } }
console.log(obj2); // 输出: { a: 3, b: { c: 4 } }
```

总的来说，浅拷贝只会复制对象或数组的第一层属性或元素，而深拷贝会递归地复制所有的属性或元素，包括嵌套的对象或数组。因此，在需要复制对象或数组时，根据具体的需求选择使用浅拷贝还是深拷贝。



### 14. 闭包是什么，闭包形成的原因和闭包的用途 ？

闭包（Closure）是指在 JavaScript 中，一个函数能够访问其外部作用域中的变量，即使在函数被调用后外部作用域已经销毁的情况下仍然可以访问这些变量。换句话说，闭包是由函数和其相关的引用环境（Lexical Environment）组合而成的。

闭包形成的原因：

1. **函数嵌套**：当一个函数内部定义了另一个函数时，内部函数可以访问外部函数的变量。
2. **函数作为返回值**：当一个函数返回另一个函数时，返回的函数仍然可以访问其定义时所在的作用域中的变量。

闭包的用途：

1. **保护变量**：通过闭包可以创建私有变量，避免全局变量污染，提高代码的安全性和可维护性。
2. **封装变量**：闭包可以将变量封装在内部函数中，隐藏实现细节，提供更清晰的接口。
3. **延长变量的生命周期**：闭包可以使变量的生命周期得到延长，即使外部函数执行完毕，闭包仍然可以访问这些变量。
4. **实现函数记忆**：闭包可以用于实现函数记忆（Memoization），缓存函数的计算结果以提高性能。
5. **实现柯里化**：闭包可以用于实现柯里化（Currying），将多参数的函数转化为单参数的函数序列。
6. **实现回调函数**：闭包可以用于实现回调函数，例如在异步编程中。

举例来说，下面是一个简单的闭包示例：

```javascript
function outerFunction() {
  const outerVariable = 'I am from outer function';

  function innerFunction() {
    console.log(outerVariable); // 内部函数可以访问外部函数的变量
  }

  return innerFunction;
}

const innerFunc = outerFunction(); // 内部函数被返回并赋值给变量
innerFunc(); // 输出: "I am from outer function"
```

在这个例子中，`innerFunction` 是一个闭包，它可以访问外部函数 `outerFunction` 中定义的变量 `outerVariable`，即使外部函数已经执行完毕。通过返回内部函数，我们创建了一个闭包，使得 `innerFunction` 在执行时仍然能够访问 `outerVariable`。



### 15. 数据对象有那些属性值？

JavaScript 中的数据对象（Object）具有多种属性值，这些属性值可以分为两类：数据属性和访问器属性。

数据属性（Data Properties）：

1. **value**：属性的值。
2. **writable**：属性是否可写，即是否可以修改属性的值。
3. **enumerable**：属性是否可枚举，即是否可以通过 for...in 循环遍历到该属性。
4. **configurable**：属性是否可配置，即是否可以通过 delete 关键字删除属性，或者修改属性的特性。

访问器属性（Accessor Properties）：

1. **get**：获取属性值的函数，当访问该属性时调用。
2. **set**：设置属性值的函数，当修改该属性时调用。
3. **enumerable**：同数据属性中的 enumerable，属性是否可枚举。
4. **configurable**：同数据属性中的 configurable，属性是否可配置。

除了以上列出的属性值，对象还具有原型链相关的属性：

1. **[[Prototype]]**：对象的原型，指向该对象继承属性和方法的原型对象。
2. **constructor**：构造函数，用于创建该对象的构造函数。



### 16. ES6有哪些函数声明方式？

ES6（ECMAScript 2015）引入了一些新的函数声明方式，让 JavaScript 编程更加灵活和便捷。以下是 ES6 中常见的函数声明方式：

1. **箭头函数（Arrow Functions）**：
   - 箭头函数是 ES6 中最显著的新特性之一，它提供了一种更简洁的函数声明方式。
   - 箭头函数使用箭头 (=>) 语法来定义函数，可以省略 function 关键字、return 关键字以及大括号（当函数体只有一条语句时）。
   - 箭头函数的 this 绑定规则与普通函数不同，它的 this 始终指向函数定义时所在的对象。
   - 示例：
     ```javascript
     // 普通函数
     function add(a, b) {
       return a + b;
     }
     
     // 箭头函数
     const add = (a, b) => a + b;
     ```

2. **函数默认参数（Default Parameters）**：
   - ES6 允许在函数参数列表中为参数设置默认值，当调用函数时未传递参数时，将使用默认值。
   - 示例：
     ```javascript
     function greet(name = 'World') {
       console.log('Hello, ' + name + '!');
     }
     greet(); // Hello, World!
     greet('Alice'); // Hello, Alice!
     ```

3. **展开操作符（Spread Operator）**：
   - 展开操作符（...）可以将数组或类数组对象展开为独立的参数序列，或者将字符串展开为字符数组。
   - 在函数声明中，可以使用展开操作符来接收不定数量的参数。
   - 示例：
     ```javascript
     function sum(...args) {
       return args.reduce((acc, curr) => acc + curr, 0);
     }
     console.log(sum(1, 2, 3)); // 6
     ```

4. **剩余参数（Rest Parameters）**：
   - 剩余参数（Rest Parameters）用于接收函数调用时传递的剩余参数，并将它们存储在一个数组中。
   - 与展开操作符相反，剩余参数用于函数声明的参数列表中。
   - 示例：
     ```javascript
     function printArgs(firstArg, ...restArgs) {
       console.log('First argument:', firstArg);
       console.log('Rest arguments:', restArgs);
     }
     printArgs(1, 2, 3, 4); // First argument: 1, Rest arguments: [2, 3, 4]
     ```

这些 ES6 中的函数声明方式为 JavaScript 编程带来了更多的灵活性和便捷性，使得代码更加清晰、简洁。







## API

### 1. map和foreach的异同是什么？

`map` 和 `forEach` 都是 JavaScript 中用于遍历数组的方法，它们有相似之处，也有一些区别。

相同点：

1. **用途**：`map` 和 `forEach` 都用于遍历数组中的每个元素，并对每个元素执行指定的操作。

2. **参数**：它们都接受一个回调函数作为参数，回调函数会在遍历数组的每个元素时被调用。

不同点：

1. **返回值**：
   - `map` 方法返回一个新数组，其中包含回调函数的返回值。
   - `forEach` 方法没有返回值，它只是用于遍历数组，而不会生成新的数组。

2. **使用场景**：
   - `map` 通常用于对数组中的每个元素进行操作，并将操作结果存储在新数组中。例如，可以使用 `map` 方法将数组中的每个元素都加倍。
   - `forEach` 通常用于遍历数组并执行一些操作，例如打印数组的每个元素或对数组中的元素进行更改，但它不会创建新的数组。

3. **可中断性**：
   - `forEach` 方法无法被中断，它会遍历完整个数组，不论是否在回调函数中返回 `false`。
   - `map` 方法在回调函数返回 `false` 时会终止遍历，并返回已经处理的元素构成的新数组。



### 2. JavaScript阻止默认事件？

- 阻止元素的默认事件：

  `event.preventDefault()`

- 阻止元素冒泡事件：

  `event.stopPropagation()`



### 3. for...in、for...of、for三种区别？

- for...in

  输出对象的key

- for...of

  遍历数组中的元素

- for

  正常循环



### 4. 常用的数组方法？

JavaScript 中常用的数组方法包括：

1. **push()**：向数组末尾添加一个或多个元素，并返回新数组的长度。
2. **pop()**：从数组末尾移除最后一个元素，并返回移除的元素。
3. **shift()**：从数组头部移除第一个元素，并返回移除的元素。
4. **unshift()**：向数组头部添加一个或多个元素，并返回新数组的长度。
5. **splice()**：从数组中添加或删除元素，可以灵活操作数组。
6. **concat()**：合并两个或多个数组，返回一个新数组。
7. **slice()**：返回数组的指定部分（浅拷贝），不修改原数组。
8. **indexOf()**：返回指定元素在数组中的索引，如果不存在返回 -1。
9. **lastIndexOf()**：返回指定元素在数组中的最后一个索引，如果不存在返回 -1。
10. **includes()**：判断数组是否包含某个元素，返回布尔值。
11. **forEach()**：遍历数组的每个元素，执行指定的回调函数。
12. **map()**：遍历数组的每个元素，执行指定的回调函数，并返回执行结果组成的新数组。
13. **filter()**：遍历数组的每个元素，执行指定的回调函数，并返回满足条件的元素组成的新数组。
14. **reduce()**：对数组的每个元素执行指定的累积函数，返回一个累积值。
15. **every()**：检测数组的每个元素是否满足指定条件，如果全部满足返回 true，否则返回 false。
16. **some()**：检测数组的至少一个元素是否满足指定条件，如果有满足的返回 true，否则返回 false。
17. **find()**：返回数组中满足指定条件的第一个元素，如果找不到返回 undefined。
18. **findIndex()**：返回数组中满足指定条件的第一个元素的索引，如果找不到返回 -1。
19. **sort()**：对数组进行排序，默认是按照字符串 Unicode 编码进行排序。
20. **reverse()**：颠倒数组中元素的顺序。

这些数组方法可以帮助开发者对数组进行各种操作，包括增删改查、遍历、筛选、转换等。



### 5. 常用字符串方法 ？

JavaScript 中常用的字符串方法包括：

1. **charAt()**：返回指定索引位置的字符。
2. **charCodeAt()**：返回指定索引位置的字符的 Unicode 编码。
3. **concat()**：连接两个或多个字符串，并返回新字符串。
4. **indexOf()**：返回指定字符第一次出现的索引位置，如果未找到返回 -1。
5. **lastIndexOf()**：返回指定字符最后一次出现的索引位置，如果未找到返回 -1。
6. **slice()**：提取字符串的片段，并返回新字符串。
7. **substring()**：提取字符串的片段，与 slice() 类似，但不支持负索引。
8. **substr()**：提取字符串的片段，从指定位置开始指定长度，并返回新字符串。
9. **startsWith()**：检查字符串是否以指定字符开头，返回布尔值。
10. **endsWith()**：检查字符串是否以指定字符结尾，返回布尔值。
11. **includes()**：检查字符串是否包含指定字符，返回布尔值。
12. **toUpperCase()**：将字符串转换为大写。
13. **toLowerCase()**：将字符串转换为小写。
14. **trim()**：去除字符串两端的空格。
15. **replace()**：替换字符串中的指定字符或模式。
16. **split()**：将字符串分割为数组，根据指定的分隔符。
17. **charAt()**：返回指定索引位置的字符。
18. **match()**：检测字符串中是否匹配指定的正则表达式，返回匹配的结果。
19. **search()**：检索字符串中指定的子字符串，返回匹配的位置。
20. **repeat()**：将字符串重复指定次数。

这些字符串方法可以帮助开发者对字符串进行各种操作，包括查找、替换、截取、转换大小写、分割、连接等。



### 6. Set和Map的异同是什么？

好的，让我们使用 Set 和 Map 来举例说明它们的用法。

Set 示例：

```javascript
// 创建一个 Set 对象
let uniqueNumbers = new Set();

// 添加元素到 Set 中
uniqueNumbers.add(1);
uniqueNumbers.add(2);
uniqueNumbers.add(3);
uniqueNumbers.add(2); // 重复添加相同的值，不会产生效果

// 判断 Set 中是否包含某个元素
console.log(uniqueNumbers.has(2)); // true
console.log(uniqueNumbers.has(4)); // false

// 获取 Set 中元素的个数
console.log(uniqueNumbers.size); // 3

// 删除 Set 中的元素
uniqueNumbers.delete(2);

// 清空 Set 中的所有元素
uniqueNumbers.clear();

// 查看最终的 Set 对象
console.log(uniqueNumbers); // Set {}
```

Map 示例：

```javascript
// 创建一个 Map 对象
let userData = new Map();

// 添加键值对到 Map 中
userData.set('name', 'John');
userData.set('age', 30);
userData.set('name', 'Jane'); // 覆盖已有的键值对

// 获取 Map 中指定键的值
console.log(userData.get('name')); // 'Jane'
console.log(userData.get('gender')); // undefined

// 判断 Map 中是否包含某个键
console.log(userData.has('age')); // true
console.log(userData.has('gender')); // false

// 获取 Map 中键值对的个数
console.log(userData.size); // 2

// 删除 Map 中的键值对
userData.delete('age');

// 清空 Map 中的所有键值对
userData.clear();

// 查看最终的 Map 对象
console.log(userData); // Map {}
```

这些示例展示了如何使用 Set 和 Map 对象，以及它们的常用方法。Set 适合用于存储一组唯一的值，而 Map 则适合用于存储键值对。



### 7. map和weakmap的区别是什么？

Map：

1. **引用类型**：Map 是一种强引用类型，它的键是强引用，不会被垃圾回收机制回收。

2. **键类型**：Map 的键可以是任意类型的值，包括基本类型和对象引用。

3. **迭代器**：Map 提供了用于迭代其键值对的方法，如 `forEach()`、`entries()`、`keys()`、`values()` 等。

4. **内存管理**：Map 中的键值对在不再被引用时，仍然会占用内存，不会被自动释放。

WeakMap：

1. **引用类型**：WeakMap 是一种弱引用类型，它的键是弱引用，有可能被垃圾回收机制回收。

2. **键类型**：WeakMap 的键必须是对象类型，不能是基本类型，否则会抛出 TypeError。

3. **迭代器**：WeakMap 不提供用于迭代的方法，因为无法确定键是否被垃圾回收。

4. **内存管理**：WeakMap 中的键值对在不再被引用时，会被自动释放，因此可以用于临时存储对象的私有数据，避免内存泄漏。

总结：

- Map 适合用于存储键值对，并且键值对需要长期保留的情况。
- WeakMap 适合用于临时存储对象的私有数据，避免内存泄漏，并且键值对的生命周期与键的引用一致。



### 8. 箭头函数的特性？

- 箭头函数没有自己的this，会捕获其所在的上下文的this值，作为自己的this值
- 箭头函数没有constructor，是匿名函数，不能作为构造函数，不能通过new 调用；
- 没有new.target 属性。在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined
- 箭头函数不绑定arguments 对象。取而代之用rest参数...解决。由于 箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立）
- 箭头函数通过 call() 或 apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。
- 箭头函数没有原型属性 Fn.prototype 值为 undefined
- 箭头函数不能当做Generator函数,不能使用yield关键字



## This

### 1. this的绑定规则是什么？

实际上this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。

this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 总结: 函数被调用时发生 this 绑定，this 指向什么完全取决于函数在哪里被调用。

1. 默认绑定（严格/非严格模式）

   window

2. 隐式绑定

   函数调用的this绑定到上下文对象

3. 显式绑定

   call，bind，apply

4. new绑定

   执行[prototype]链接，绑定到函数调用的this



### 2. call，bind和apply的异同是什么？

`bind`、`apply` 和 `call` 是 JavaScript 中用于修改函数执行上下文的方法，它们有一些相似之处，但也有一些不同之处。

相同点：

1. **修改函数执行上下文**：`bind`、`apply` 和 `call` 都可以用于修改函数的执行上下文，即指定函数中 `this` 关键字所指向的对象。

不同点：

1. **参数传递方式**：
   - `bind`：返回一个新函数，新函数会将指定的对象作为执行上下文，并将指定的参数作为新函数的参数。
   - `apply`：接受两个参数，第一个参数是要绑定的执行上下文，第二个参数是一个数组或类数组对象，数组中的元素会作为参数传递给函数。
   - `call`：接受一个参数列表，第一个参数是要绑定的执行上下文，后续参数是要传递给函数的参数，每个参数都会直接传递给函数。

2. **返回值**：
   - `bind`：返回一个绑定了指定上下文的新函数，但不会立即执行该函数。
   - `apply` 和 `call`：立即调用函数，并指定函数的执行上下文和参数，返回函数执行的结果。

3. **使用场景**：
   - `bind`：常用于绑定函数的执行上下文，并在稍后的时间点调用该函数。
   - `apply` 和 `call`：常用于立即调用函数，并指定函数的执行上下文和参数。`apply` 适用于参数以**数组形式**存在的情况，而 `call` 适用于参数以**单独列举**的情况。

总的来说，`bind`、`apply` 和 `call` 都是用于修改函数执行上下文的方法，它们的主要区别在于参数传递方式、返回值和使用场景。



## 原型链

### 1. 原型，原型链 ? 有什么特点？

JavaScript 中的原型（prototype）和原型链（prototype chain）是理解 JavaScript 面向对象编程的关键概念之一。它们具有以下特点：

1. **原型（prototype）**：
   - 每个 JavaScript 对象都有一个原型对象（prototype），它是对象的一个属性，可以是另一个对象或者 null。
   - 原型对象用于继承属性和方法，当对象访问一个不存在的属性或方法时，JavaScript 引擎会沿着原型链查找，直到找到对应的属性或方法或者到达原型链的尽头（null）。

2. **原型链（prototype chain）**：
   - 原型链是由对象的原型对象（prototype）组成的链式结构。
   - 当访问对象的属性或方法时，JavaScript 引擎会首先在对象本身上查找，如果找不到则沿着原型链向上查找，直到找到对应的属性或方法或者到达原型链的尽头。
   - 原型链的尽头是 Object.prototype，它是所有对象的根原型。

3. **特点**：
   - JavaScript 中的对象是通过原型链来实现继承的。
   - 对象的属性和方法可以在其原型对象上定义，所有该对象的实例都可以共享这些属性和方法。
   - 当修改对象的原型对象时，所有该对象的实例都会受到影响，因为它们共享同一个原型对象。
   - 原型链的存在使得 JavaScript 具有了动态性和灵活性，可以方便地扩展和修改对象的属性和方法。

总之，JavaScript 的原型和原型链是实现对象之间继承关系的机制，通过原型链，对象可以共享原型对象上的属性和方法，实现了高效的代码复用和扩展。



## 同步异步

### 1. async await 和promise和generator有什么区别？

`async/await` 和 Promise 是处理 JavaScript 异步编程的两种主要方式，而 Generator 函数也可以用于实现异步操作，但它们之间有一些区别和优劣势。

Promise：

- Promise 是 ES6 新增的一种异步编程解决方案，它可以更清晰、更简洁地处理异步操作。
- Promise 可以轻松地处理多个异步操作，通过链式调用 `then()` 方法或使用 `async/await` 来解决回调地狱问题。
- Promise 可以通过 `resolve()` 和 `reject()` 来返回异步操作的结果或错误。
- Promise 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败），可以通过 `then()` 方法或 `catch()` 方法处理这些状态。

async/await：

- `async/await` 是 ES2017（ES8）新增的一种异步编程语法糖，基于 Promise 实现，可以更优雅地处理异步代码。
- `async` 关键字用于定义一个异步函数，该函数内部可以使用 `await` 关键字来暂停执行并等待 Promise 解决或拒绝。
- `await` 关键字只能在 `async` 函数内部使用，用于等待 Promise 对象的状态改变，并返回异步操作的结果。
- `async/await` 让异步代码看起来像同步代码，提高了代码的可读性和可维护性。

Generator：

- Generator 是 ES6 新增的一种特殊函数，可以通过 `function*` 关键字来定义。
- Generator 函数内部使用 `yield` 关键字可以使函数执行停止，并返回一个可迭代对象，用于实现惰性计算和异步操作。
- Generator 函数的执行可以通过 `next()` 方法控制，每次调用 `next()` 方法会使函数执行到下一个 `yield` 关键字处，直到函数执行完毕或遇到 `return` 关键字为止。

总结：

- 使用 Promise 可以更灵活地处理异步操作，并且可以解决回调地狱问题。
- `async/await` 提供了一种更优雅、更直观的异步编程方式，让异步代码看起来像同步代码。
- Generator 函数可以用于实现惰性计算和异步操作，但相对于 Promise 和 `async/await`，它的语法更复杂，使用起来相对不那么直观。



### 2. 手写promise ？

参考手撕文件夹下的笔记。



### 3. promise.all()的作用？

1. **并行执行多个异步操作**：`Promise.all` 可以同时发起多个异步操作，并且在所有操作完成后才返回结果。这对于需要同时进行多个异步操作并且在所有操作完成后处理结果的场景非常有用。

2. **等待所有异步操作完成**：`Promise.all` 可以用于等待多个异步操作全部完成后再执行后续操作。例如，在前端开发中，可以使用 `Promise.all` 等待多个网络请求全部完成后再更新页面。



## 通信

### 1. 跨域的解决方案有哪些？

在 JavaScript 中，跨域（Cross-Origin）指的是在浏览器中加载的网页尝试与不同源（即协议、域名或端口）的服务器进行交互，由于同源策略的限制，这种跨域请求通常会受到限制。为了解决跨域问题，可以采用以下几种方案：

1. **JSONP（JSON with Padding）**：JSONP 是一种利用 `<script>` 标签可以跨域加载的特性来实现跨域通信的方法。它的原理是通过在页面中动态创建 `<script>` 标签，指向一个包含 JSON 数据的 URL，服务器返回的数据会被当做 JavaScript 脚本执行，从而实现跨域数据的获取。

2. **CORS（Cross-Origin Resource Sharing）**：CORS 是一种由服务器端实现的跨域解决方案，通过在服务器端设置响应头来指示浏览器是否允许跨域请求。可以通过设置 `Access-Control-Allow-Origin` 头来允许特定源的请求，还可以设置其他 CORS 相关头来控制跨域请求的行为，比如允许的请求方法、允许的请求头等。

3. **代理（Proxy）**：通过在服务器端设置代理来转发请求，从而绕过浏览器的同源策略限制。例如，在前端将请求发送到同源的服务器，然后由同源服务器转发请求到目标服务器，最后将响应返回给前端，这样就实现了跨域请求。

4. **WebSocket**：WebSocket 是一种双向通信协议，可以在浏览器和服务器之间建立持久连接，实现实时通信。由于 WebSocket 不受同源策略的限制，因此可以用于跨域通信。

5. **跨文档消息传递（Cross-document Messaging）**：通过 `window.postMessage()` 方法来发送消息，实现不同窗口或 iframe 之间的跨域通信。这种方式适用于同一浏览器窗口下的跨域通信，但不适用于跨浏览器窗口的通信。

6. **跨域资源嵌入（Cross-Origin Resource Embedding）**：通过在 HTML 中使用 `<link>`、`<script>`、`<img>` 等标签来加载跨域资源，从而实现跨域数据的获取。例如，可以通过在页面中插入 `<img>` 标签来获取图片资源，或者通过 `<script>` 标签来加载 JSONP 数据。

这些方法各有优缺点，具体应根据实际情况选择合适的跨域解决方案。



### 2. 什么是长轮询？

长轮询（Long Polling）是一种实现实时数据更新的技术，它是一种 HTTP 长连接的变种。在长轮询中，客户端向服务器发送一个请求，服务器保持请求打开直到有新的数据可用或超时。一旦有新数据可用，服务器立即响应请求，客户端收到响应后立即再次发送新的请求，以保持连接。

长轮询的特点包括：

- **实时性较高**：长轮询允许服务器立即响应有新数据可用的请求，从而实现实时更新的效果。
- **较高的资源消耗**：由于长轮询需要维持大量的连接，因此会增加服务器的资源消耗。
- **延迟较高**：长轮询会导致客户端和服务器之间的延迟较高，因为客户端需要等待服务器响应才能发送新的请求。

长轮询适用于需要实时更新的应用场景，比如在线聊天、实时通知等。然而，由于其资源消耗较高和延迟较高的特点，随着 WebSocket 技术的发展，长轮询已经逐渐被 WebSocket 所取代，WebSocket 在实时通信方面更加高效和灵活。



### 3. HTTP 响应状态码都有哪些？

HTTP 响应状态码表示服务器对请求的处理结果，分为以下几类：

1. 1xx（Informational）：请求已接收，继续处理。
2. 2xx（Success）：请求成功接收并处理。
   - 200 OK：请求成功。
   - 201 Created：资源已被成功创建。
   - 204 No Content：请求成功，但响应不包含任何内容。
3. 3xx（Redirection）：需要进行额外操作以完成请求。
   - 301 Moved Permanently：资源已永久移动到新位置。
   - 302 Found：资源暂时移动到新位置。
   - 304 Not Modified：客户端已缓存的资源未修改。
4. 4xx（Client Error）：请求包含错误或无法完成请求。
   - 400 Bad Request：请求无效。
   - 401 Unauthorized：未授权访问。
   - 403 Forbidden：禁止访问资源。
   - 404 Not Found：未找到资源。
5. 5xx（Server Error）：服务器无法完成请求。
   - 500 Internal Server Error：服务器内部错误。
   - 502 Bad Gateway：上游服务器返回无效响应。
   - 503 Service Unavailable：服务器暂时无法处理请求。



### 4. 阐述Javascript的同源策略？

同源策略（Same-Origin Policy）是浏览器中一种重要的安全策略，用于限制来自不同源（Origin）的文档或脚本对当前文档的访问。

两个 URL 具有相同的 origin，如果它们具有相同的协议（protocol）、主机（host）和端口（port）。

同源策略的限制：

1. **JavaScript 限制**：来自不同源的 JavaScript 脚本不能访问当前文档的 DOM，也不能通过 AJAX 等方式获取当前文档的内容。

2. **Cookie 限制**：浏览器限制了来自不同源的页面对当前页面的 Cookie 的读取。即使在相同的浏览器标签页中，不同源的页面也无法访问彼此的 Cookie。

3. **DOM 限制**：来自不同源的页面无法通过 JavaScript 直接操作彼此的 DOM 结构。



## 场景

### 1. 手写防抖和节流，同时他们的区别是什么？

参考手撕文件夹下的笔记。



## 性能

### 1. 垃圾回收方法？

JavaScript 的垃圾回收是自动进行的，开发者无需手动介入。JavaScript 的垃圾回收器会周期性地扫描内存中的对象，并标记那些不再被引用的对象，然后释放它们所占用的内存空间。

JavaScript 中的主要垃圾回收方法包括：

1. **标记-清除算法（Mark and Sweep）**：这是 JavaScript 中最常见的垃圾回收算法。它通过标记不再使用的对象，然后清除那些被标记的对象来回收内存。标记阶段会遍历所有的可访问对象，并标记为活动对象，而清除阶段会清除未标记的对象。

2. **引用计数（Reference Counting）**：这是一种比较简单的垃圾回收方法，在每个对象中维护一个引用计数器，记录有多少个引用指向该对象。当引用计数为零时，说明对象不再被引用，可以被回收。然而，引用计数方法容易出现循环引用的情况，导致内存泄漏。



### 2. 举一个闭包会影响垃圾回收的例子？

这种行为有时会导致内存泄漏的问题，特别是在使用闭包的时候需要注意避免循环引用。例如，在事件处理函数中创建了一个闭包，并将该事件处理函数绑定到 DOM 元素上，如果不及时解绑事件处理函数，那么闭包中引用的外部变量将会一直存在，即使 DOM 元素被销毁，也无法被垃圾回收器回收。



## 设计模式

### 1. 继承的多种方式有哪些？分别是什么？优缺点？

JavaScript 中实现继承的方式有多种，每种方式都有其特点和适用场景。以下是常见的几种继承方式：

1. **原型链继承**：
   - 原型链继承通过将子类的原型指向父类的实例来实现继承。
   - 缺点是所有子类实例共享同一个父类实例的属性，容易造成属性共享和污染的问题。
   - 示例：
     ```javascript
     function Parent() {
       this.name = 'Parent';
     }
     function Child() {}
     Child.prototype = new Parent();
     ```

2. **构造函数继承（借用构造函数）**：
   - 构造函数继承通过在子类构造函数内部调用父类构造函数来实现继承。
   - 缺点是不能继承父类原型上的属性和方法。
   - 示例：
     ```javascript
     function Parent() {
       this.name = 'Parent';
     }
     function Child() {
       Parent.call(this);
     }
     ```

3. **组合继承（原型链 + 构造函数）**：
   - 组合继承结合了原型链继承和构造函数继承的优点，既可以继承父类的原型属性和方法，又可以实现实例属性的独立。
   - 缺点是在创建子类实例时，会调用两次父类构造函数，导致父类实例属性被重复添加。
   - 示例：
     ```javascript
     function Parent() {
       this.name = 'Parent';
     }
     function Child() {
       Parent.call(this);
     }
     Child.prototype = new Parent();
     Child.prototype.constructor = Child;
     ```

4. **原型式继承**：
   - 原型式继承通过复制一个对象作为新对象的原型来实现继承。
   - 缺点是所有属性都是共享的，没有办法实现属性的独立。
   - 示例：
     ```javascript
     var parent = {
       name: 'Parent'
     };
     var child = Object.create(parent);
     ```

5. **寄生式继承**：
   - 寄生式继承是在原型式继承的基础上增强了对象，返回增强后的对象作为子类。
   - 缺点是同样无法实现属性的独立，且增强函数会产生额外的消耗。
   - 示例：
     ```javascript
     function createChild(obj) {
       var child = Object.create(obj);
       child.sayHello = function() {
         console.log('Hello!');
       };
       return child;
     }
     ```

6. **寄生组合式继承**：
   - 寄生组合式继承是组合继承的一种优化方式，避免了调用两次父类构造函数。
   - 缺点是增加了额外的函数调用，略微影响性能。
   - 示例：
     ```javascript
     function Parent() {
       this.name = 'Parent';
     }
     function Child() {
       Parent.call(this);
     }
     Child.prototype = Object.create(Parent.prototype);
     Child.prototype.constructor = Child;
     ```

以上是 JavaScript 中常见的几种继承方式，每种方式都有其优缺点，开发者根据实际需求选择适合的继承方式。