# 节流和防抖

## 节流

### 节流是什么？

在JavaScript中，节流是一种用于**限制函数的执行频率**的技术。

它有助于减少事件处理程序或函数的调用次数，特别是在处理高频事件（比如滚动事件、鼠标移动事件等）时非常有用。

节流是确保函数在**一定时间间隔**内**只被执行一次**，从而减少不必要的计算和资源消耗，提高页面性能和用户体验。



### 节流的主要目的是什么？

1. **性能优化**：节流可以减少浏览器的负担，避免因为高频率的事件触发而导致页面性能下降，特别是在处理复杂的逻辑或者大量的DOM操作时。
2. **防止过度触发事件**：有些事件可能会被频繁地触发，例如滚动事件或者鼠标移动事件。如果不进行节流，每次事件触发都会触发相应的函数执行，可能导致页面行为不受控制或者性能下降。
3. **优化用户体验**：通过控制函数的执行频率，可以使得页面的交互更加平滑和流畅，避免因为过多的函数执行而导致页面卡顿或者延迟响应。



### 如何实现节流？

**注意：**以下代码都不含带参形式。

#### 计时器

```javascript
// 一段时间内，只执行一次某个操作；过了这段时间的话，还有操作的话，继续执行新的操作
function throttle(fn) {
    let timer = null;

    return function () {
        if (timer) {
            return
        }
        timer = setTimeout(() => {
            fn();
            timer = null;
        }, 200);
    }
}
```



#### 时间戳

```javascript
function throttle(fn) {
    var timer;

    return function () {
        if (!timer || Date.now() - timer >= 200) {
            fn();
            timer = Date.now();
        }
    }
}
```



### 有哪些使用场景？

1. **滚动事件**：当页面被滚动时，会频繁地触发滚动事件。如果有一些涉及到滚动位置的复杂计算或者DOM操作，可以使用节流来限制这些操作的执行频率，以提高性能和响应速度。

   ```javascript
   // 定义加载更多内容的函数
   function loadMoreContent() {
       console.log("加载更多内容...");
       // 在这里执行加载更多内容的操作
   }
   
   // 创建节流函数，设置延迟时间为 500 毫秒
   const throttleScroll = throttle(function () {
       // 当滚动到页面底部时触发加载更多内容的操作
       if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) {
           loadMoreContent();
       }
   }, 500);
   
   // 监听滚动事件，并使用节流函数处理
   window.addEventListener('scroll', throttleScroll);
   
   // 节流函数实现
   function throttle(func, delay) {
       let timeoutId;
       return function (...args) {
           if (!timeoutId) {
               timeoutId = setTimeout(() => {
                   func.apply(this, args);
                   timeoutId = null;
               }, delay);
           }
       };
   }
   ```

   在这个例子中，当用户滚动页面时，滚动事件会被监听，但是实际执行加载更多内容的操作会通过节流函数进行限制，确保在每次滚动事件触发后的500毫秒内只执行一次加载更多内容的操作。这样可以避免在用户频繁滚动页面时触发大量的加载更多内容的操作，提高页面性能和用户体验。

   

2. **输入框实时搜索**：在输入框中进行实时搜索时，每次输入都会触发搜索操作。为了减少不必要的网络请求和服务器负载，可以使用节流来确保只在用户停止输入一段时间后才执行搜索操作。

   ```javascript
   function search(keyword) {
     console.log("正在搜索关键字:", keyword);
     // 在这里执行搜索操作，并更新搜索结果显示
   }
   
   // 创建节流函数，设置延迟时间为 500 毫秒
   const throttleSearch = throttle(function(keyword) {
     search(keyword);
   }, 500);
   
   // 获取搜索输入框元素
   const searchInput = document.getElementById('searchInput');
   
   // 监听输入框输入事件，并使用节流函数处理
   searchInput.addEventListener('input', function(event) {
     const keyword = event.target.value;
     throttleSearch(keyword);
   });
   
   // 节流函数实现
   function throttle(func, delay) {
     let timeoutId;
     return function(...args) {
       if (!timeoutId) {
         timeoutId = setTimeout(() => {
           func.apply(this, args);
           timeoutId = null;
         }, delay);
       }
     };
   }
   ```

   在这个例子中，当用户在输入框中输入内容时，输入事件会被监听。每次输入事件触发时，会调用节流函数，并传入输入的关键字作为参数。节流函数确保在每次输入事件触发后的500毫秒内只执行一次搜索操作，从而避免频繁触发搜索请求，提高性能和用户体验。

   在输入框实时搜索的场景中，一般会选择 debounce 而不是 throttle 的原因是，我们希望在用户停止输入一段时间后再进行搜索，而不是限制搜索的执行频率。用户可能在输入时进行调整或者修改，我们希望等待用户停止输入一段时间后再进行搜索操作，以避免频繁的搜索请求，节省服务器资源并提高用户体验。

   

3. **窗口调整事件**：当浏览器窗口大小调整时，会触发窗口调整事件。如果有一些依赖于窗口大小的布局或者样式计算，可以使用节流来限制这些计算的执行频率，以避免页面频繁重排和重新绘制，提高性能。

   

4. **鼠标移动事件**：当鼠标在页面上移动时，会触发鼠标移动事件。如果有一些需要根据鼠标位置进行实时更新的操作，可以使用节流来限制这些操作的执行频率，以提高性能和响应速度。

   

5. **按钮点击事件**：当用户频繁点击按钮时，可能会触发一些重复性的操作。为了避免多次重复执行相同的操作，可以使用节流来限制按钮点击事件的执行频率，以确保每次点击只触发一次操作。



## 防抖

### 防抖是什么？

防抖（Debounce）是一种用于限制函数调用频率的技术。它确保函数在连续触发的一系列事件中，只执行一次，并且是在最后一个事件发生一定时间后执行。

具体来说，防抖函数会等待一段时间（称为防抖延迟），如果在这段时间内没有再次触发函数，那么函数将被执行。如果在这段时间内函数被再次触发，那么之前设置的执行操作会被取消，并重新开始计时。



### 防抖的主要目的是什么？

1. **降低资源消耗**：在一些频繁触发的操作场景下，比如用户连续输入文字、频繁调整窗口大小等，如果每次事件触发都立即执行相应的处理函数，可能会导致不必要的资源消耗，尤其是在处理复杂的逻辑或大量的DOM操作时。通过防抖，可以控制函数的执行频率，减少不必要的计算和资源消耗。
2. **提升性能**：在一些需要等待用户停止操作后才执行的场景下，比如输入框实时搜索、窗口调整大小等，如果立即执行处理函数，可能会导致频繁的操作和页面重绘，降低性能和响应速度。通过防抖，可以等待一定时间，直到用户停止操作，然后再执行相应的处理，从而提升性能和用户体验。
3. **避免重复操作**：在一些需要等待用户停止操作后执行的场景下，如果没有防抖机制，可能会导致相同的操作被重复执行多次，比如多次发送重复的搜索请求、多次进行重复的布局调整等。通过防抖，可以确保在一定时间内只执行一次相应的处理函数，避免重复操作的发生。



### 如何实现防抖？

```javascript
function debounce(fn, time) {
    let timer;
    
    return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, args);
        }, time)
    }
}
```



### 有哪些使用场景？

1. **输入框实时搜索**：当用户在输入框中输入文字时，每次输入都可能触发搜索操作。为了避免频繁地发起搜索请求，可以使用防抖来确保只有在用户停止输入一段时间后才执行搜索操作。
2. **窗口调整大小**：当用户调整浏览器窗口大小时，会触发窗口调整大小事件。在一些需要重新计算布局或者样式的情况下，可以使用防抖来确保只在用户停止调整窗口大小一段时间后才执行相应的操作，避免频繁地重绘页面。
3. **表单验证**：在用户输入表单内容时，可以使用防抖来延迟验证用户输入，以减少验证操作的频率，提高用户体验。
4. **按钮点击事件**：在一些需要防止用户频繁点击的场景下，可以使用防抖来确保只有在用户停止点击一段时间后才执行相应的操作，避免重复操作或者误操作。
5. **滚动事件**：在一些需要处理滚动事件的情况下，比如实现无限滚动加载更多内容的功能，可以使用防抖来确保只有在用户停止滚动一段时间后才执行加载更多内容的操作，避免频繁地发起加载请求。
